# go-notes
go

http://c.biancheng.net/view/3990.html

# 并发模型
Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无须处理回调，无须关注线程切换，仅一个关键字，简单而自然。

搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。

# 内存分配
内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。

# 垃圾回收

GC算法
1. 引用计数
每个单元维护一个域，保存其他单元指向它的引用数量，当引用的数量为0时，将其回收。

优点：

算法易实现
内存管理与用户程序交织在一起，将GC的代价分散到整个程序，不用STW
缺点

不能处理循环引用
维护引用计数降低运行效率
2. 标记-清扫
是一种自动内存管理，基于追踪的垃圾收集算法。垃圾回收程序对所有的存活单元进行一次全局遍历确定哪些单元可以回收。算法分为两部分：标记和清扫。标记阶段表明所有存活单元，清扫阶段将垃圾回收。

优点：

避免了引用计数不能处理循环引用的缺点
缺点：

STW（挂起程序）
三色标记算法：对标记阶段的改进（标记过程和用户程序并发进行）

起初所有对象都是白色
从根出发扫描所有可达对象，标记为灰色，放入待处理队列
从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色
重复3，直到灰色对象队列为空，此时白色对象即为垃圾，进行回收

参考 https://www.jianshu.com/p/b434dfbec6d8
